package crud

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/gobeam/stringy"
	"github.com/jackc/pgx/v4"
	"github.com/pkg/errors"
	cmnutils "github.com/tkcrm/modules/pkg/utils"
	"github.com/tkcrm/pgxgen/internal/config"
	"github.com/tkcrm/pgxgen/internal/generator"
	"github.com/tkcrm/pgxgen/pkg/sqlc"
	"github.com/tkcrm/pgxgen/utils"
)

type ICRUD interface {
	generator.IGenerator
	GenerateConstants() error
}

type crud struct {
	config config.Config
}

func New(cfg config.Config) ICRUD {
	return &crud{
		config: cfg,
	}
}

func (s *crud) Generate(args []string) error {
	res, err := s.process()
	if err != nil {
		return errors.Wrap(err, "process error")
	}

	queriesPaths := s.config.Sqlc.GetPaths().QueriesPaths

	// remove generated files
	for _, p := range queriesPaths {
		if err := s.removeGeneratedFiles(p); err != nil {
			return errors.Wrap(err, "remove generated files error")
		}
	}

	// save new files
	tableNamePaths := make(map[string]string, len(res))
	for tableName, data := range res {
		tableParams, ok := s.config.Pgxgen.CrudParams.Tables[tableName]
		if !ok {
			return fmt.Errorf("can not find table params for table: %s", tableName)
		}

		if tableParams.OutputDir != "" {
			tableNamePaths[tableParams.OutputDir] = tableName

			if err := s.saveFile(data, tableName, tableParams.OutputDir); err != nil {
				return errors.Wrap(err, "saveFile error")
			}

			continue
		}

		for _, p := range queriesPaths {
			tableNamePaths[p] = tableName

			if err := s.saveFile(data, tableName, p); err != nil {
				return errors.Wrap(err, "saveFile error")
			}
		}
	}

	fmt.Println("crud successfully generated")

	return nil
}

func (s *crud) process() (map[string][]byte, error) {
	result := make(map[string][]byte, len(s.config.Sqlc.GetPaths().OutPaths))

	for _, outPath := range s.config.Sqlc.GetPaths().OutPaths {
		// Get all tables from postgres
		tablesData, err := s.getTableMeta(outPath)
		if err != nil {
			return nil, err
		}

		//headText := fmt.Sprintf("-- Code generated by pgxgen. DO NOT EDIT.\n-- versions:\n--   pgxgen %s\n\n", s.config.Pgxgen.Version)
		//builder.WriteString(headText)

		// Sort tables
		tableKeys := make([]string, 0, len(s.config.Pgxgen.CrudParams.Tables))
		for k := range s.config.Pgxgen.CrudParams.Tables {
			tableKeys = append(tableKeys, k)
		}
		sort.Strings(tableKeys)

		for _, tableName := range tableKeys {
			tableParams := s.config.Pgxgen.CrudParams.Tables[tableName]

			metaData := tablesData.getTableMetaData(tableName)
			if metaData == nil {
				return nil, fmt.Errorf("database does not exist table: \"%s\"", tableName)
			}

			// Sort methods
			methodKeys := make([]string, 0, len(tableParams.Methods))
			for k := range tableParams.Methods {
				methodKeys = append(methodKeys, k.String())
			}
			sort.Strings(methodKeys)

			builder := new(strings.Builder)

			for _, methodType := range methodKeys {
				methodParams := tableParams.Methods[config.MethodType(methodType)]

				params := processParams{
					builder,
					tableName,
					*metaData,
					methodParams,
					tableParams,
				}

				var err error
				switch config.MethodType(methodType) {
				case METHOD_CREATE:
					err = s.processCreate(params)
				case METHOD_UPDATE:
					err = s.processUpdate(params)
				case METHOD_DELETE:
					err = s.processDelete(params)
				case METHOD_GET:
					err = s.processGet(params)
				case METHOD_FIND:
					err = s.processFind(params)
				case METHOD_TOTAL:
					err = s.processTotal(params)
				case METHOD_EXISTS:
					err = s.processExists(params)
				}

				if err != nil {
					return nil, errors.Wrap(err, fmt.Sprintf(ErrWhileProcessTemplate, methodType, tableName))
				}
			}

			result[tableName] = []byte(builder.String())
		}
	}

	return result, nil
}

// getTableMetaOld - deprecated
func (s *crud) getTableMetaOld(connString string) (tables, error) {
	groupData := make(tables)

	conn, err := pgx.Connect(context.Background(), connString)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to database: %v", err)
	}
	defer conn.Close(context.Background())

	rows, err := conn.Query(context.Background(), `
		SELECT attrelid::regclass AS TABLE_NAME,
			attname AS COLUMN_NAME
		FROM pg_attribute
		INNER JOIN pg_class ON pg_class.oid = attrelid
		WHERE attrelid IN
			(SELECT pg_class.oid
			FROM pg_class
			INNER JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
			WHERE pg_namespace.nspname IN ('public')
			AND pg_class.relkind IN ('r', 't'))
		AND attnum > 0
		AND attisdropped IS FALSE
		ORDER  BY pg_class.relname,
					pg_attribute.attnum
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := []tableColumns{}
	for rows.Next() {
		var i tableColumns
		if err := rows.Scan(
			&i.TableName,
			&i.ColumnName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	for _, item := range items {
		metaData, ok := groupData[item.TableName]
		if !ok {
			groupData[item.TableName] = &tableMetaData{
				columns: []string{item.ColumnName},
			}
		} else {
			groupData[item.TableName].columns = append(metaData.columns, item.ColumnName)
		}
	}

	return groupData, nil
}

func (s *crud) getTableMeta(outputDir string) (tables, error) {
	groupData := make(tables)

	catalog, err := sqlc.GetCatalogByOutputDir(outputDir)
	if err != nil {
		return nil, err
	}

	for _, schema := range catalog.Catalog.Schemas {
		for _, table := range schema.Tables {
			if _, ok := groupData[table.Rel.Name]; !ok {
				groupData[table.Rel.Name] = &tableMetaData{}
			}

			tableMeta := &tableMetaData{
				columns: make([]string, len(table.Columns)),
			}

			for i, column := range table.Columns {
				tableMeta.columns[i] = column.Name
			}

			groupData[table.Rel.Name] = tableMeta
		}
	}

	return groupData, nil
}

func (s *crud) processCreate(p processParams) error {
	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_CREATE, p.table)
	}

	operationType := "exec"
	if p.methodParams.Returning != "" {
		operationType = "one"
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :%s\n", methodName, operationType))
	p.builder.WriteString("INSERT INTO ")
	p.builder.WriteString(p.table)
	p.builder.WriteString(" (")

	filteredColumns := cmnutils.FilterValues(p.metaData.columns, p.methodParams.SkipColumns)
	for index, name := range filteredColumns {
		if index > 0 && index < len(filteredColumns) {
			p.builder.WriteString(", ")
		}

		p.builder.WriteString(name)
	}
	p.builder.WriteString(")\n\tVALUES (")

	lastIndex := 1
	for index, name := range filteredColumns {
		if index > 0 && index < len(filteredColumns) {
			p.builder.WriteString(", ")
		}

		if name == "created_at" {
			p.builder.WriteString("now()")
		} else {
			p.builder.WriteString(fmt.Sprintf("$%d", lastIndex))
			lastIndex++
		}
	}

	p.builder.WriteString(")")
	if p.methodParams.Returning != "" {
		p.builder.WriteString("\n\tRETURNING *")
	}
	p.builder.WriteString(";\n\n")

	return nil
}

func (s *crud) processUpdate(p processParams) error {
	primaryColumn, err := getPrimaryColumn(p.metaData.columns, p.table, p.tableParams.PrimaryColumn)
	if err != nil {
		return err
	}

	if primaryColumn == "" {
		return ErrUndefinedPrimaryColumn
	}

	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_UPDATE, p.table)
	}

	operationType := "exec"
	if p.methodParams.Returning != "" {
		operationType = "one"
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :%s\n", methodName, operationType))
	p.builder.WriteString("UPDATE ")
	p.builder.WriteString(p.table)
	p.builder.WriteString("\n\tSET ")

	lastIndex := 1
	filteredColumns := cmnutils.FilterValues(p.metaData.columns, p.methodParams.SkipColumns)
	for index, name := range filteredColumns {
		if index > 0 && index < len(filteredColumns) {
			p.builder.WriteString(", ")
			if len(p.metaData.columns) > 6 && index%6 == 0 {
				p.builder.WriteString("\n\t\t")
			}
		}

		if name == "updated_at" {
			p.builder.WriteString("updated_at=now()")
		} else {
			p.builder.WriteString(fmt.Sprintf("%s=$%d", name, lastIndex))
			lastIndex++
		}
	}

	p.builder.WriteString("\n\t")
	p.methodParams.AddWhereParam(primaryColumn, config.WhereParamsItem{})

	if err := s.processWhereParam(p, METHOD_UPDATE, &lastIndex); err != nil {
		return err
	}

	if p.methodParams.Returning != "" {
		p.builder.WriteString("\n\tRETURNING *")
	}
	p.builder.WriteString(";\n\n")

	return nil
}

func (s *crud) processDelete(p processParams) error {
	primaryColumn, err := getPrimaryColumn(p.metaData.columns, p.table, p.tableParams.PrimaryColumn)
	if err != nil {
		return err
	}

	if primaryColumn == "" {
		return ErrUndefinedPrimaryColumn
	}

	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_DELETE, p.table)
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :exec\n", methodName))
	p.builder.WriteString("DELETE FROM ")
	p.builder.WriteString(p.table)

	lastIndex := 1
	p.methodParams.AddWhereParam(primaryColumn, config.WhereParamsItem{})

	if err := s.processWhereParam(p, METHOD_DELETE, &lastIndex); err != nil {
		return err
	}
	p.builder.WriteString(";\n\n")

	return nil
}

func (s *crud) processGet(p processParams) error {
	primaryColumn, err := getPrimaryColumn(p.metaData.columns, p.table, p.tableParams.PrimaryColumn)
	if err != nil {
		return err
	}

	if primaryColumn == "" {
		return ErrUndefinedPrimaryColumn
	}

	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_GET, p.table)
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :one\n", methodName))
	p.builder.WriteString("SELECT * FROM ")
	p.builder.WriteString(p.table)

	lastIndex := 1
	p.methodParams.AddWhereParam(primaryColumn, config.WhereParamsItem{})

	if err := s.processWhereParam(p, METHOD_GET, &lastIndex); err != nil {
		return err
	}
	p.builder.WriteString(" LIMIT 1;\n\n")

	return nil
}

func (s *crud) processFind(p processParams) error {
	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_FIND, p.table)
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :many\n", methodName))
	p.builder.WriteString("SELECT * FROM ")
	p.builder.WriteString(p.table)
	lastIndex := 1
	if err := s.processWhereParam(p, METHOD_FIND, &lastIndex); err != nil {
		return err
	}
	if order := getOrderByParams(p.methodParams, p.table); order != nil {
		p.builder.WriteString(fmt.Sprintf(" ORDER BY %s %s", order.By, order.Direction))
	}
	if p.methodParams.Limit {
		p.builder.WriteString(fmt.Sprintf(" LIMIT $%d OFFSET $%d", lastIndex, lastIndex+1))
	}
	p.builder.WriteString(";\n\n")
	return nil
}

func (s *crud) processTotal(p processParams) error {
	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_TOTAL, p.table)
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :one\n", methodName))
	p.builder.WriteString("SELECT count(*) as total FROM ")
	p.builder.WriteString(p.table)
	lastIndex := 1
	if err := s.processWhereParam(p, METHOD_TOTAL, &lastIndex); err != nil {
		return err
	}
	p.builder.WriteString(";\n\n")

	return nil
}

func (s *crud) processExists(p processParams) error {
	methodName := p.methodParams.Name
	if methodName == "" {
		methodName = s.getMethodName(METHOD_EXISTS, p.table)
	}

	p.builder.WriteString(fmt.Sprintf("-- name: %s :one\n", methodName))
	p.builder.WriteString("SELECT EXISTS (SELECT * FROM ")
	p.builder.WriteString(p.table)
	lastIndex := 1
	if err := s.processWhereParam(p, METHOD_EXISTS, &lastIndex); err != nil {
		return err
	}
	p.builder.WriteString(")::boolean;\n\n")

	return nil
}

func (s *crud) processWhereParam(p processParams, method config.MethodType, lastIndex *int) error {
	// process where params
	if params := getWhereParams(p.methodParams, p.table, method); len(params) > 0 {
		// Sort params
		paramsKeys := make([]string, 0, len(params))
		for k := range params {
			paramsKeys = append(paramsKeys, k)
		}
		sort.Strings(paramsKeys)

		firstIter := true
		for _, param := range paramsKeys {
			item := params[param]

			if !cmnutils.ExistInArray(p.metaData.columns, param) {
				return fmt.Errorf("param %s does not exist in table %s", param, p.table)
			}

			if firstIter {
				strPattern := " "
				if method == METHOD_UPDATE {
					strPattern = ""
				}

				p.builder.WriteString(strPattern + "WHERE ")
			} else {
				p.builder.WriteString(" AND ")
			}

			if item.Value == "" {
				operator := item.Operator
				if operator == "" {
					operator = "="
				}

				p.builder.WriteString(fmt.Sprintf("%s%s$%d", param, operator, *lastIndex))
				*lastIndex++
			} else {
				p.builder.WriteString(param)
				if item.Operator != "" {
					p.builder.WriteString(fmt.Sprintf(" %s", item.Operator))
				}
				p.builder.WriteString(fmt.Sprintf(" %s", item.Value))
			}
			firstIter = false
		}
	}

	// process where additional params
	if params := getWhereAddtitionalParams(p.methodParams, p.table, method); len(params) > 0 {
		whereParamsLen := len(getWhereParams(p.methodParams, p.table, method))

		for paramIndex, param := range params {
			if paramIndex == 0 && whereParamsLen == 0 {
				p.builder.WriteString(" WHERE ")
			} else {
				strPattern := " "
				if paramIndex > 0 {
					strPattern = "\t"
				}
				p.builder.WriteString(strPattern + "AND ")
			}

			strPattern := "%s"
			if paramIndex < len(params)-1 {
				strPattern += "\n"
			}

			p.builder.WriteString(fmt.Sprintf(strPattern, param))
		}
	}

	return nil
}

func (s *crud) saveFile(data []byte, tableName, path string) error {
	tableParams, ok := s.config.Pgxgen.CrudParams.Tables[tableName]
	if !ok {
		return fmt.Errorf("can not find table params for table: %s", tableName)
	}

	if tableParams.OutputDir != "" && tableParams.OutputDir != path {
		return nil
	}

	if tableName == "" {
		return errors.New("empty table name")
	}

	fileName := fmt.Sprintf("%s_gen.sql", tableName)
	if err := utils.SaveFile(path, fileName, data); err != nil {
		return errors.Wrap(err, "SaveFile error")
	}

	return nil
}

// func (s *crud) getMethodParams(methodType config.MethodType, p processParams) config.Method {
// 	res := p.methodParams
// 	return res
// }

func (s *crud) getMethodName(methodType config.MethodType, tableName string) string {
	var methodName string
	if s.config.Pgxgen.CrudParams.ExcludeTableNameFromMethods {
		methodName = methodType.String()
	} else {
		methodName = fmt.Sprintf("%s %s", methodType.String(), tableName)
	}

	methodName = stringy.New(methodName).CamelCase()

	if !cmnutils.ExistInArray([]config.MethodType{METHOD_FIND, METHOD_TOTAL}, methodType) {
		if strings.HasSuffix(methodName, "s") {
			methodName = string(methodName[:len(methodName)-1])
		}
	}

	return methodName
}

func getPrimaryColumn(columns []string, table, column string) (string, error) {
	primaryColumn := ""
	if column != "" {
		if !cmnutils.ExistInArray(columns, column) {
			return primaryColumn, fmt.Errorf("table %s does not have a primary column %s", table, column)
		}
		primaryColumn = column
	}

	return primaryColumn, nil
}

func getWhereParams(method config.Method, table string, methodType config.MethodType) map[string]config.WhereParamsItem {
	params := make(map[string]config.WhereParamsItem)

	methodLower := strings.ToLower(methodType.String())

	// Skip create method
	if methodLower == "create" {
		return params
	}

	// Sort params
	keys := make([]string, 0, len(method.Where))
	for k := range method.Where {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, param := range keys {
		params[param] = method.Where[param]
	}

	return params
}

func getWhereAddtitionalParams(method config.Method, table string, methodType config.MethodType) []string {
	params := make([]string, len(method.WhereAdditional))

	methodLower := strings.ToLower(methodType.String())

	// Skip create method
	if methodLower == "create" {
		return params
	}

	if len(method.WhereAdditional) > 0 {
		return method.WhereAdditional
	}

	return params
}

func getOrderByParams(method config.Method, table string) *config.OrderParam {
	if method.Order.By == "" {
		return nil
	}

	if method.Order.Direction == "" {
		method.Order.Direction = "DESC"
	}

	return &method.Order
}

func (s *crud) removeGeneratedFiles(path string) error {
	if !s.config.Pgxgen.CrudParams.AutoRemoveGeneratedFiles {
		return nil
	}

	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		return nil
	}

	dirItems, err := os.ReadDir(path)
	if err != nil {
		return err
	}
	for _, item := range dirItems {
		if item.IsDir() {
			continue
		}

		if strings.HasSuffix(item.Name(), "_gen.sql") {
			filePath := filepath.Join(path, item.Name())
			if err := os.Remove(filePath); err != nil {
				return err
			}
		}
	}

	return nil
}
