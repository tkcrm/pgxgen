package sqlc

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/tkcrm/pgxgen/internal/config"
	"github.com/tkcrm/pgxgen/internal/generator"
	"github.com/tkcrm/pgxgen/internal/goconstatnts"
	"github.com/tkcrm/pgxgen/internal/structs"
	"github.com/tkcrm/pgxgen/pkg/logger"
	sqlcpkg "github.com/tkcrm/pgxgen/pkg/sqlc"
)

type sqlc struct {
	logger      logger.Logger
	config      config.Config
	goConstants goconstatnts.IGoConstants
}

func New(logger logger.Logger, cfg config.Config) generator.IGenerator {
	return &sqlc{
		logger:      logger,
		config:      cfg,
		goConstants: goconstatnts.New(logger, cfg),
	}
}

func (s *sqlc) Generate(_ context.Context, args []string) error {
	if err := s.process(args); err != nil {
		return fmt.Errorf("failed to generate sqlc: %w", err)
	}

	return nil
}

func (s *sqlc) process(args []string) error {
	timeStart := time.Now()

	// generate sqlc code
	genResult := sqlcpkg.Run(args)
	if genResult != 0 {
		return nil
	}

	s.logger.Infof("sqlc code successfully generated in: %s", time.Since(timeStart))

	// check sqlc config version
	if !slices.Contains([]string{"1", "2"}, s.config.Sqlc.Version) {
		return fmt.Errorf("unsupported sqlc version: %s", s.config.Sqlc.Version)
	}

	// validate sqlc model params
	for _, item := range s.config.Pgxgen.Sqlc {
		if err := item.Validate(); err != nil {
			return fmt.Errorf("validate pgxgen sqlc config error: %w", err)
		}

		if item.SqlcModels.Move.IsUsable() {
			if err := item.SqlcModels.Move.Validate(); err != nil {
				return fmt.Errorf("validate sqlc model move params error: %w", err)
			}
		}
	}

	modelsMoved := map[string]structs.Structs{}

	// process sqlc model params
	for _, cfg := range s.config.Pgxgen.Sqlc {
		param := cfg.SqlcModels

		// get model paths for current schema
		filteredModelPaths, err := config.GetPathsByScheme(
			s.config.Sqlc.GetPaths(),
			cfg.SchemaDir,
			"models",
		)
		if err != nil {
			return fmt.Errorf("GetPathsByScheme error: %w", err)
		}

		if len(filteredModelPaths) == 0 {
			continue
		}

		s.logger.Infof("processing for sqlc models for schema: %s", cfg.SchemaDir)
		timeStart = time.Now()

		for _, modelPath := range filteredModelPaths {
			modelFileDir := filepath.Dir(modelPath)
			modelFileName := filepath.Base(modelPath)

			files, err := os.ReadDir(modelFileDir)
			if err != nil {
				return fmt.Errorf("failed to read path %s: %w", modelFileDir, err)
			}

			// process all `.go` files in a directory, that generated by sqlc
			for _, file := range files {
				goFileRegexp := regexp.MustCompile(`(\.go)`)

				// skip not golang files
				if !goFileRegexp.MatchString(file.Name()) {
					continue
				}

				// replace nullable types
				if param.ReplaceSqlcNullableTypes &&
					(strings.HasSuffix(file.Name(), ".sql.go") ||
						file.Name() == "querier.go" ||
						file.Name() == modelFileName) {
					if err := s.replace(
						filepath.Join(modelFileDir, file.Name()),
						replaceStructTypes,
					); err != nil {
						return fmt.Errorf("replaceStructTypes error: %w", err)
					}
				}
			}

			// move sqlc model file
			if param.Move.IsUsable() {
				if err := s.moveModels(
					cfg,
					&modelsMoved,
					files,
					modelPath,
					modelFileDir,
					modelFileName,
				); err != nil {
					return fmt.Errorf("moveModels error: %w", err)
				}
			}
		}

		s.logger.Infof("processing for sqlc models successfully finished in: %s", time.Since(timeStart))
	}

	// generate go constants
	if err := s.goConstants.GenerateConstants(); err != nil {
		return err
	}

	return nil
}
